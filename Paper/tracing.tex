\documentclass{article}

\usepackage{verbatimfiles}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{url}
\usepackage{multirow}
\usepackage{fancyhdr}
\usepackage{relsize}

\usepackage[pdftex,usenames]{color}
\usepackage[pdftex]{graphicx}  
\DeclareGraphicsExtensions{.pdf}  
\usepackage[pdftex,bookmarks=true,bookmarksnumbered=true,hypertexnames=false,breaklinks=true]{hyperref}
\hypersetup{
  pdfauthor = {Jean Utke},
  pdftitle = {Tracing Nonsmooth Model Behavior},
  pdfsubject = {},
  pdfkeywords = {OpenAD, Fortran, automatic differentiation, algorithms},
  pdfcreator = {LaTeX with hyperref package},
  pdfproducer = {dvips + ps2pdf}sh	
}
\pdfadjustspacing=1

% make paragraphs show up in the bookmarks
\setcounter{secnumdepth}{6}
\setcounter{tocdepth}{6}

% names and CS terms

% math
\newcommand{\R}{I\!\!R}
\newcommand{\N}{I\!\!N	}
\newcommand{\bmC}{\mbox{\bf\em C}}
\newcommand{\bmf}{\mbox{\bf\em f}}
\newcommand{\bmfp}{\mbox{\bf\em f$\,^\prime\!\!$}}
\newcommand{\bmg}{\mbox{\bf\em g}}
\newcommand{\bmI}{\mbox{\bf\em I}}
\newcommand{\bmJ}{\mbox{\bf\em J}}
\newcommand{\bmp}{\mbox{\bf\em p}}
\newcommand{\bmq}{\mbox{\bf\em q}}
\newcommand{\bmS}{\mbox{\bf\em S}}
\newcommand{\bms}{\mbox{\bf\em s}}
\newcommand{\bmt}{\mbox{\bf\em t}}
\newcommand{\bmu}{\mbox{\bf\em u}}
\newcommand{\bmv}{\mbox{\bf\em v}}
\newcommand{\bmw}{\mbox{\bf\em w}}
\newcommand{\bmx}{\mbox{\bf\em x}}
\newcommand{\bmy}{\mbox{\bf\em y}}
\newcommand{\bmzero}{\mbox{\bf\em O}}

% environments
\newcommand{\code}[1]{{\tt{#1}}}
\newcommand{\refcan}[1]{(C\ref{#1})}
\newcommand{\refsec}[1]{{Sec.~\ref{#1}}} 
\newcommand{\refsecBS}[1]{{Section~\ref{#1}}} 
\newcommand{\reffig}[1]{{Fig.~\ref{#1}}} 
\newcommand{\reffigBS}[1]{{Figure\ref{#1}}} 
\newcommand{\reftab}[1]{{Table~\ref{#1}}} 
\newcommand{\refalg}[1]{{Alg.~\ref{#1}}} 
\newcommand{\refalgBS}[1]{{Algorithm~{#1}}} 
\newcommand{\refeqn}[1]{{(\ref{#1})}} 
\newcommand{\refdef}[1]{{Def.~(\ref{#1})}} 

\title{A tracing facility for Nonsmooth Model Behavior}
\author{J. Utke\\\\
        \small Preprint version: \input{versionInfo.txt} compiled for \\
        \small OpenAD version: \input{versionInfoOpenAD.txt}\\
        \small xaifBooster version: \input{versionInfoxaifBooster.txt}\\
}
\date{ }

\fancyhead[RE]{\leftmark}
\fancyhead[LE]{}
\fancyhead[RO]{}
\fancyhead[LO]{\nouppercase\rightmark}
\fancyfoot[LO,RE]{Tracing Nonsmooth Model Behavior}

\begin{document}
\maketitle
\lstloadlanguages{Fortran,XML}
\lstset{basicstyle=\footnotesize\tt, 
	numbers=left, 
	numberstyle=\scriptsize,
  	stepnumber=1, 
	numbersep=10pt, 
	breaklines=true,
	resetmargins=false,
	xleftmargin=6ex,
	columns=fullflexible}
% #########################################################################################
\section{Introduction}

The computation of derivatives in the context of optimization, parameter or state estimation 
and other uses relies on the assumption that the function computed by the numerical 
model is in some sense ``smooth''. 
This is true for the approximation of derivative information with divided differences 
as well as the application of automatic differentiation (AD). 
Griewank devotes an entire chapter in \cite{Gri00} 
to the scenario of applying an AD tool to cases without differentiability. 
In practice one observes various cases where the derivatives computed by AD are useless 
because their numerical values grow  beyond reasonable bounds \cite{tfs-delayed,tfs-chain} or even 
become NaNs. 
In the latter case one might have the option to let a suitable compiler generate 
code to detect floating point exceptions to help locate the origin of the problem.
The AD  tool ADIFOR \cite{adiforWeb} also has built-in  option to detect 
such situations by adding checks to the generated code.   
In the former case when no NaNs are created it is however very difficult to 
detect what feature of the numerical model causes the derivative values to explode. 
In the following we introduce a facility to trace the model computation and locate 
certain programming constructs that have the potential to cause 
such behavior. We aim at extracting information that is specific to 
certain locations in the underlying program and also to specific data 
being computed during the execution of the model.  
   
Many numerical models exhibit nonsmooth behavior to reflect the modeled problem, 
for instance a phase change in the modeled material, because the 
model has distinct representations for certain subdomains or the nonsmooth effects 
are an artifact of the numerical methods implemented in the model.
In either case one needs to be concerned about the validity of the 
derivative information and attempt to locate the problem and  find a remedy.  
The situation with the disctinct subdomains is described to illustrate 
certain aspects of using Adol-C in \cite{adolc} and we 
replicate it here in \reffig{fig:subdomains}. 
\begin{figure}
\centerline{\includegraphics[width=6cm]{nonsmooth1}}
\caption{A nonsmooth model with subdomains}\label{fig:subdomains} 
\end{figure}
The model is first evaluated at point P0.  Relative to P0 we distinguish the 
following cases
\begin{description}
\item[P1] we stay in the interior of the same subdomain as P0 
\item[P2 and P2'] we are in the interior of a different subdomain than P0 is
\item[P3] we are at a point where the model is continuous but not (Frech\'et) differentiable
\item[P4] we are at a point where the model is not continuous
\item[P5] we are at a point where the model is not defined
\end{description}    
For Adol-C the most critical question is to determine if a given execution trace 
recorded for some point P0 may still be used for a different point P' or else 
into which of the five categories  the point P' falls that would necessitate 
a re-recording of the execution trace and indicate if the computed derivatives 
may be valid only in the given direction. Adol-C itself provides only an answer 
via a return code indicating the category. 
It is able to do this by comparing the output of tests and certain intrinsics 
that were recorded in the execution trace with the output these same tests and intrinsics 
generate at the current evaluation point. 
Because the execution trace is generated via operator overloading and is designed to 
minimize the required storage an indication of leaving the current subdomain or computing 
a value at a point of non-differentiability cannot be related to a particular spot in 
the underlying program or a particular piece of data. 
However, the idea is the same that certain programming constructs can
trigger the assumption that one has left the subdomain in which smooth model behavior 
can be assumed. 
These {\em critical} programming constructs can be grouped as follows.
\begin{description}
\item[nonsmooth intrinsics] Some of the most obvious cases are \code{max}, \code{min}, and \code{fabs}.
\item[conditional expressions] The model may compute values in different branches following a test 
or a loop may have a different iteration count based on a termination test.
\end{description}
As done in Adol-C we aim at tracing the model behavior and detect any differences triggered 
by the programming constructs listed above that might represent nonsmooth model behavior.
Obviously a tracing facility such as the one proposed here is most useful for 
numerical models that have 
\begin{itemize}
\item a large source code base and 
\item a relatively long execution time
\end{itemize}
such that a manual inspection of the model either by browsing the source code or 
running a simulation in the debuger to observe certain values is too tedious.
Clearly such a use also requires some restrictions on the information that is being 
collected to reduce the amount of tracing data that has to be dealt with.


% #########################################################################################
\section{Usage}

The source transformation that provides the tracing facility is implemented in the 
OpenAD framework \cite{openad}. The website\\ 
\centerline{\url{www.mcs.anl.gov/openad}}\\
provides details on the downloading and building the tool chain. 

% -----------------------------------------------------------------------------------------
\subsection{One Minute Example}
We assume a simple routine computing $y=f(x)=\tan(x)$ implemented by \lstinline{head}.
\begin{figure}
\lstinputlisting{Code/OneMinuteExample/head.f90}
\caption{Simple example code}\label{fig:oneMinute}
\end{figure}
We need to prepare the code for the activity analysis by specifying the indpendent variables
(here \lstinline{x}) and the dependent variables (here \lstinline{y})
\begin{figure}
\lstinputlisting{Code/OneMinuteExample/head.prepped.f90}
\caption{Augmented code from \reffig{fig:oneMinute}}\label{fig:oneMinutePrepped}
\end{figure}
In the following we assume the OpenAD environment has been set up as 
described in \cite{userManual} Sect. 2.2.
For this simple example we can use the  wrapper script\\[1ex]
\hspace*{1cm}\lstinline{$OPENADROOT/bin/openad}\\[1ex] %$
The directory should have been added to the \lstinline{PATH}. 
It provides a simple recipe for the tracing transformation that we can use in 
a straightforward case like this. When invoked like\\[1ex] 
\hspace*{1cm}\lstinline{openad -m t head.prepped.f90}\\[1ex]
it produces some progress output on the screen like this\\[1ex]
\hspace*{1cm}\begin{minipage}{\textwidth}
\small\verbatimfile{oneMinuteStatusOutput.txt}
\vspace*{1ex}
\end{minipage}
The resulting fortran output is contained in a file called\\[1ex]
\hspace*{1cm}\lstinline{head.prepped.xb.x2w.w2f.pp.f}\\[1ex] 
and its contents is shown in \reffig{fig:OneMinuteTransformed}  
\begin{figure}
\lstinputlisting{Code/OneMinuteExample/head.prepped.xb.x2w.w2f.pp.f}
\caption{Transformed code (fixed format) from input shown in \reffig{fig:oneMinutePrepped}}\label{fig:oneMinuteTransformed}
\end{figure}
In the transformed Fortran one finds two versions of the code, one is the original 
on line 28 and one is augmented on lines 32--36. Which version is being run depends 
on the value of the components of \lstinline{our_rev_mode} which is to be controled 
by a driver that calls \lstinline{head(x,y)}.
A simple such driver is shown in \reffig{fig:oneMinuteDriver}. 
\begin{figure}
\lstinputlisting{Code/OneMinuteExample/driver.f90}
\caption{Driver routine for the transformed code  shown in \reffig{fig:oneMinuteTransformed}}\label{fig:oneMinuteDriver}
\end{figure}
On line 11 a generic initialization of the tracing environment is performed.  A First trace is 
started on line 12. The call to \lstinline{oad_trace_open} opens a file called 
\lstinline{oad_tr_001.xml} and sets up the running mode \lstinline{oad_rev_mode} 
referenced on lines 26 and 30 of \reffig{fig:OneMinuteTransformed}.
In the driver we change then the value at which we compute \lstinline{head} and 
open a second trace which is named \lstinline{oad_tr_002.xml}. 
The \lstinline{openad} script links the required run time support files 
to the working directory and all files can be compiled with 
a \lstinline{makefile} such as the one shown in \reffig{fig:OneMinuteMake}.
\begin{figure}
\hspace*{.5cm}\begin{minipage}{\textwidth}
\scriptsize\verbatimfile{Code/OneMinuteExample/Makefile}
\end{minipage}
\caption{Contents of a \lstinline{makefile} to compile and link the example.}\label{fig:OneMinuteMake}.
\end{figure}.

The contents of the trace output files generated when running \lstinline{driver} 
is shown in \reffig{fig:OneMinuteXMLOutput}.
\begin{figure}
\begin{minipage}{.5\textwidth}
\lstinputlisting{Code/OneMinuteExample/oad_tr_001.xml}
\end{minipage}
\begin{minipage}{.5\textwidth}
\lstinputlisting{Code/OneMinuteExample/oad_tr_002.xml}
\end{minipage}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated from \reffig{fig:oneMinuteDriver}}\label{fig:OneMinuteXMLOutput}
\end{figure}
Clearly the tracing outputs are identical except for line 4 where we show the 
different output for the respective smooth subdomain \lstinline{sd} at which the 
\lstinline{tan} intrinsic is being evaluated. The interpretation of the subdomain of $\tan(x)$ 
is \lstinline{sd=}$k$ with integer $k=\lfloor\frac{x+\pi/2)}{\pi}\rfloor$ and in our 
example the change in the \lstinline{sd} value  indicates that we moved from one smooth 
subdomain to another. 
We note that the subdomain is computed at the time when the intrinsic is called. Line 2 and 3 
are generated seperately prior to the call to allow to generate line number information 
and if necessary also information about the arguments, see also \refsec{sec:ArrayIndex}.

% -----------------------------------------------------------------------------------------
\subsection{Detailled Usage}
The transformation of the source code is performed in stages in the same fashion as 
summarized in the OpenAD Manual \cite{userManual}, Sect. 2.5. 
The differences in the tool chain are the choice of the transformation algorithm 
in the xaifBooster component and the selection of the runTime library in connection with 
the postprocessor templates. 
The stages prior to the tracing transformation are 
\begin{itemize}
\item collecting all the model program sources into a  single source code file; declaration of independent and dependent program variables (see \cite{userManual}, Sect. 2.3)
\item canonicalization (optional, see \cite{userManual}, Sect. 4.2.1)
\item parsing Fortran with the Open64 front-end (\lstinline{mfef90}, see \cite{userManual}, Sect. 4.2.2)
\item translating the Open64 internal representation to xaif (\lstinline{whirl2xaif}, see \cite{userManual}, Sect. 4.2.3)
\end{itemize}
The stages following the tracing transformation are 
The transformation steps after this stage are as follows
\begin{itemize}
\item translating from xaif to the Open64 internal representation (\lstinline{xaif2whirl}, see \cite{userManual}, Sect. 4.2.3)
\item unparsing the Open64 internal representation into Fortran (\lstinline{whirl2f}, see \cite{userManual}, Sect. 4.2.2)
\item postprocessing (see \cite{userManual}, Sect. 4.2.4)
\item compile and link (see \cite{userManual}, Sect. 2.6)
\end{itemize}
% -----------------------------------------------------------------------------------------
\subsubsection{The Tracing Transformation}
The numerical model is now given as an xaif file to which we apply the tracing transformation. 
Conceptually, the tracing transformation shares the following aspects with other 
AD-related transformations implemented in 
OpenAD:
\begin{itemize}
\item redeclaration of program variables using a special, {\em active} type these variables 
	have been determined to hold active values by the activity analysis.
\item transformation associated with this type change, for instance as  applied to 
	calls to black box subroutines
\item augmentation of the control flow graph, for instance to be able to count loop iterations
\end{itemize}
The transformation options associated with the tracing facility are as follows.
{\scriptsize
\verbatimfile{tracingAlgOpts.txt}
}
As shown for instance for the example in \reffig{fig:OneMinuteTransformed} the 
transformation generates two different versions of the input code on a per subroutine basis. 
The first one is essentially the input containing only changes related to the 
type change of active variables. The second version is the actual tracing. 
% -----------------------------------------------------------------------------------------
\subsubsection{Runtime Support Files}
The following files support the implementation of the tracing transformation.
\begin{description}
\item[{\tt ad\_template.f}:] the template file used by the postprocessor to inject the two code versions created per 
subroutine into a control structure that makes up the new subroutine body; a simple version of such a template file 
can be found in\\[1ex]   
\hspace*{1cm}\lstinline{$OPENADROOT/runTimeSupport/simple/ad_template.trace.f} \\[1ex]%$
The name of the template file can be specified to the postprocessor \lstinline{multi-pp.pl} using
\lstinline{-f <template_file_name>} or specified in the source code inside each subroutine body using 
the \lstinline{!$openad  XXX Template <template_file_name>} %$
pragma. If nothing is specified the postprocessor expects a template file named \lstinline{ad_template.f} in the 
current working directory.  \\[1ex]
\hspace*{1cm}\lstinline{$OPENADROOT/runTimeSupport/simple/OAD_trace.f90} \\[1ex]%$ the module that contains 
the routines used to generate the trace xml output. For instance related to the tracing of 
the calls to the \lstinline{tan} intrinsic it contains a module procedure\\[1ex]
\lstinputlisting[firstline=347,lastline=351]{Code/OneMinuteExample/OAD_trace.f90}
The routines to be called directly by the user are discussed in \refsec{sec:DriverRoutine}.
\item[{\tt w2f\_\_types.f90} and {\tt iaddr.c}:] the generic support files needed by most OpenAD transformed source code;
the files can be found in \\[1ex]
\hspace*{1cm}\lstinline{$OPENADROOT/runTimeSupport/all/}%$
\item[{\tt OAD\_active.f90} and {\tt OAD\_rev.f90}:] the definition for the active type and the state 
controlling the version of the code to be executed;
the files can be found in \\[1ex]
\hspace*{1cm}\lstinline{$OPENADROOT/runTimeSupport/simple/}%$
\end{description}
Except for the template file listed as the first item all other files are just compiled and linked 
with the transformed model source and a suitable driver.

% -----------------------------------------------------------------------------------------
\subsubsection{Driver Routine}\label{sec:DriverRoutine}

We assume some program logic (the {\em driver}) that initializes the input variables of the model, executes the model 
computation itself and then processes the output values. 
That driver logic  is the natural location for orchestrating the tracing of the model. 
All the required elements to be added to the driver logic are already given in the example 
in \reffig{fig:OneMinuteDriver}. The required modules to be used are \lstinline{OAD_active}, 
\lstinline{OAD_trace}. A third module \lstinline{OAD_rev} is used by \lstinline{OAD_trace}
internally. The routines to be called by user in the driver are as follows.
\begin{description}
\item[{\tt oad\_trace\_init}:] initialize the tracing module by resetting the file counter
\item[{\tt oad\_trace\_open}:] start a new trace; increments the file name counter 
\item[{\tt oad\_trace\_close}:] close a trace file opened with \lstinline{oad_trace_open}
\end{description}   
If the scope of the trace is smaller than the entire model computation (see also \refsec{sec:GrowingDerivatives})
then it may be necessary to place pairs of calls to \lstinline{oad_trace_open} and \lstinline{oad_trace_close} inside the model 
source code. 

% +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Concepts}
% -----------------------------------------------------------------------------------------
\subsection{Tracing and Activity Analysis}\label{sec:ActivityAnalysis}
An important concept in AD is that of {\em active} values, that is 
program data that lies on a dependency path from the subset of inputs $\bmx$ to 
a subset of outputs $\bmy$. 
In a source transformation context the activity is determined by a data flow 
analysis which. Typically the dependence of a given value on $\bmx$ is 
referred to as being {\em varied} while $\bmy$ depending on 
a certain value is referred to as that value being {\em usefull}.   
In general we assume a model of the form 
\[
(\bmy,\bmq)=\bmf(\bmx,\bmp): \R^{n\times s}\mapsto \R^{m\times t}
\]
The inputs $\bmp$ and the outputs $\bmq$  are assumed to be of no interest 
for the derivative computation. Consequently any values that only depend on
$\bmp$ or only affect the $\bmq$ are not ative values and  
under certain conditions of no interest to the trace we need to compare against. 
It is important to note that this restriction is specific to the AD context 
and is the distinguishing factor that separates our  approach  
from something that might otherwise be accomplished 
by using, for example, aspect oriented programming techniques. 
Typical examples for portions of the code that do not involve active values 
is logic for debugging, logging, timing or I/O.   

Our approach relies on compile time activity analysis to determine the active value set 
and source transformation to augment the critical programming constructs by 
routines that generate the trace. 
Because of conservative assumptions regarding the 
aliasing of variables there is a certain overestimate of the active value set. 
The overestimate could in theory be reduced by augmenting the static analysis 
with run time data. 
Such runtime augmentation has,  however,  the same principal problem already 
explained before for the usage of the Adol-C trace. 
One will always have to check 
if the runtime data are still valid once the point of evaluation moves. 
In other words it would be subject to the very same nonsmooth model behavior we are trying to detect.

On the other hand it is clear that the activity  analysis requiring a value 
to be both varied and usefull can underestimate 
the values for which tracing may be desired. 
The example in \reffig{fig:missedThis} illustrates the case of an active value  $a$
being part of the computation of some value $p$ that itself is not active presumably 
because it is ``varied'' but not ``usefull''.
Then $v$ is used in an if-condition that changes the path through the control flow 
graph for some  subsequent computation of active values.
\begin{figure}
\begin{lstlisting}
v = t + sin(a) 
if ( v .gt. 0.3 )
then 
  a = a * 2
else
  a = a * 3
end if 
...
\end{lstlisting}
\caption{A control flow decision depening on a nonactive variable}\label{fig:missedThis} 
\end{figure}
Given this scenario one might arrive at various conclusions. 

Rather than tracing critical constructs only for  active values 
one could devise an extension to the notion of activity using the following 
definition.\\
{\em Definition: } A value is called {\em indirectly usefull} 
if an address computation yielding active values depends on it.\\
Here we use the term  address computation to cover the typical notion of 
computing addresses in the program's data segment but also to compute 
addresses in the programs text segment determining the next instruction. 
The instruction address computation is already illustrated by \reffig{fig:missedThis}
An example for the former kind of address computation is given in 
\reffig{fig:addressComp} where an active value in variable a is used to 
determine an index i into a lookup table t which then is used in 
subsequent active computations.
\begin{figure}
\begin{lstlisting}
i = int(a) 
a = a * t(i)
\end{lstlisting}
\caption{An address computation into a lookup table impacting the subsequent computation}\label{fig:addressComp} 
\end{figure}
Unfortunately the definition of ``indirectly usefull'' cannot be directly used in a 
data flow analysis engine. 

An alternative would be to consider tracing of critical constructs for all varied values. 
Clearly, this will increase the generated output significantly by including much 
of the ancillary model logic (the aforementioned debugging, monitoring etc.) which 
the activity analysis is aiming to exclude. 
Incidentally, in Adol-C this approach is implicitly enforced by the compiler. 
Adol-C uses a specific  
active type for active values and they may not be used to 
compute plain floating point values unless one 
explicitly deactivates the value first. 

Given the difficulty of implementing an analysis to determine indirectly usefull values 
on the one hand and the large overhead of tracing all varied values we 
compromise with a limited extension to the notion of active variables by tracing  
all expressions in control flow constructs and address computations directly involving active values
but excluding all cases of computing non-active values that use one or more intermediate 
variables before the actual address computation takes place. 
While this opens up the possibility to miss some critical constructs 
it also permits a tighter restriction on what is being traced as a first iteration. 
Other than the size of the tracing data  there is no problem with abandoning the compromise
and use just the set of varied values should the first iteration not be able to 
locate any problems.    
In \refsec{sec:analysis} we discuss the practical implementation.

% -----------------------------------------------------------------------------------------
\subsection{Growing Derivatives}\label{sec:GrowingDerivatives}
In various practical applications of AD it was observed that particularly in iterative
models the are cases where the  computed derivatives before a certain iteration count 
oscillate and grow out of bounds. 
This was described for instance in \cite{tfs-delayed}. 
We do not presume any knowledge about origin of the nonsmooth behavior, for instance
it may well originate with an erroneous implementation of a numerical method. 
A simple example should illustrate how oscillating derivatives and the growth 
of the amplitude might be related to switching between smooth subdomains. 
Consider an iteration internal to the model that computes some physical state 
on a discretized domain but because of a boundary condition the state value is 
forced to attain another value. For example one might think of a heating process involving 
a phase change and the temperature of the material is forced down to a certain ambient 
value on the boundary of the model domain. 
In the iterative process one first observes a smooth rise in temperature until the 
regime that governs the phase change triggers a nonsmooth behavior. 
The situtation is illustrated in \reffig{fig:growingExample}.
\begin{figure}
\begin{lstlisting}
do while time .lt. timeEnd
  call computeTemp(T)
  if (T(border) .gt. fixedBorderTemp + delta)  then 
    T(border) = fixedBorderTemp 
  end if
  time = time + timeStep
end do  
\end{lstlisting}
\includegraphics[height=4cm]{nonsmooth2}
\caption{An iterative model with nonsmooth behavior yields 
growing derivative values.}\label{fig:growingExample} 
\end{figure}
An oscillation of the derivative values can originate for example from 
switching between two subdomains as depicted in  \reffig{fig:oscillatingExample}.
\begin{figure}
\begin{lstlisting}
do while time .lt. timeEnd
  if ( a .gt. a\_critical ) 
  then
     a=a+update\_for\_f1(a)
  else 	
     a=a+update\_for\_f2(a)
  end if
  time = time + timeStep
end do  
\end{lstlisting}
\includegraphics[height=4cm]{nonsmooth3}
\caption{An iterative model with nonsmooth behavior yields 
oscillating derivative values.}\label{fig:oscillatingExample} 
\end{figure}
The solution to fix the model behavior in this simple example is very obvious
but in complicated numerical models the effect of the updated in combination with 
switching the model regime in the control flow may not be obvious at all. 
Using the suggested tracing one would, however, record the switches in 
the control flow path based on the value of a. 
Both examples also indicate that one has to consider the  scope in which 
one wants to compare traces. Here we assume a time stepping scheme 
outside of the ``core'' model which we trace and this implies a comparison 
of traces for different time steps.  
If a model already contains iterations, e.g. if we considered the time stepping 
loops part of our example models, one will have to narrow the scope to 
subtraces within the model. 

% #########################################################################################
\section{Examples}
A study on large model computation with  a setup of the MIT general circulation model 
is currently underway.  
Here we want to illustrate the use of the tracing facility on three small examples.
% -----------------------------------------------------------------------------------------
\subsection{Control Flow}
Control flow decisions depending on active variables are illustrated in the example in 
\reffig{fig:ControlFlow}.
\begin{figure}
\lstinputlisting{Code/ControlFlow/head.prepped.f90}
\caption{An example for control flow decisions depending in active variables}\label{fig:ControlFlow} 
\end{figure} 
Both the loop bounds and the branch condition depend on the active input.  
The XML tracing elements representing structured control flow constructs are nested accordingly. 
The \lstinline{<Cfval>} element preceding a \lstinline{</Branch>} indicates what the branch 
condition evaluated to. Similarly, the \lstinline{<Cfval>} element preceding a \lstinline{</Loop>} 
indicates the number of loop iterations performed.       
The \lstinline{head} routine 
is run at two  points [0.5,0.75] and [0.5,1.75] for the inputs [\lstinline{x1},\lstinline{x1}].
For the first point the loop has three iterations, for the second one four. The condition in the loop body always evaluates to false for the first point and to true in the last three loop iteratrions for the second point. The output files are shown in \reffig{fig:ControlFlowOutput}. 
\begin{figure}
\begin{minipage}{.5\textwidth}
\lstinputlisting{Code/ControlFlow/oad_tr_001.xml}
\end{minipage}
\begin{minipage}{.5\textwidth}
\lstinputlisting{Code/ControlFlow/oad_tr_002.xml}
\end{minipage}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated for \reffig{fig:ControlFlow}}\label{fig:ControlFlowOutput}
\end{figure}
The structure may become more apparent if the xml file is viewed  
with a browser such as firefox that has an appropriate style sheet for presenting xml files 
and allows to collapse and expand an element and the contents nested inside. 
% -----------------------------------------------------------------------------------------
\subsection{Array Indices}\label{sec:ArrayIndex}
It may not always be straightforward to determine which program variables 
are being referenced, in particular if one uses array indices but the loop 
boundaries do not depend on active variables. Consequently the trace will 
also contain index values to help determine which data causes a change. 
Such a case is shown in \reffig{fig:ArrayIndex}.
\begin{figure}
\lstinputlisting{Code/ArrayIndex/head.prepped.f90}
\caption{An example for tracing array indices}\label{fig:ArrayIndex} 
\end{figure} 
We compute the \lstinline{head} routine at points [0.5,0.75] and [0.5,3.75].
For the first point both calls to $\tan$ are in subdomain 0, for the second 
\begin{figure}
\begin{minipage}{.5\textwidth}
\lstinputlisting{Code/ArrayIndex/oad_tr_001.xml}
\end{minipage}
\begin{minipage}{.5\textwidth}
\lstinputlisting{Code/ArrayIndex/oad_tr_002.xml}
\end{minipage}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated for \reffig{fig:ArrayIndex}}\label{fig:ArrayIndexOutput}
\end{figure}
point the second call is in subdomain 1. Looking at the output shown in \reffig{fig:ArrayIndexOutput}
we see that for each call to $\tan$ we also show the index of the active argument. 
This allows to easily pinpoint changes for certain elements in large arrays.    
% -----------------------------------------------------------------------------------------
\subsection{Call Stack}
In the output shown so far the listing of the line numbers and the 
nesting of the respective XML elements provides some means of navigating the 
tracing output. A natural higher level of XML element nesting would be 
the subroutine. For that reason we also introduce subroutine calls into the trace. 
The example in \reffig{fig:CallStack} shows routines \lstinline{foo} and \lstinline{bar}
called within \lstinline{head}.
\begin{figure}
\lstinputlisting{Code/CallStack/head.prepped.f90}
\caption{An example for tracing subroutine calls}\label{fig:ArrayIndex} 
\end{figure} 
We compute the \lstinline{head} routine at points 0.5 and 1.0. Because \lstinline{bar} 
is called both within \lstinline{foo} and directly in \lstinline{head} it would be 
helpfull to know the callstack at the point of a tracing difference. 
The output shown in \reffig{fig:ArrayIndexOutput} has for better readability 
been reformatted with \lstinline{xmlformat} \cite{xmlformat} and 
indicates that the only change in the subdomain (third line from the bottom)
is related to the call to \lstinline{bar} made directly in foo.
\begin{figure}
\begin{minipage}{.5\textwidth}
\scriptsize
\verbatimfile{Code/CallStack/oad_tr_001.fxml}
\end{minipage}
\begin{minipage}{.5\textwidth}
\scriptsize
\verbatimfile{Code/CallStack/oad_tr_002.fxml}
\end{minipage}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated for \reffig{fig:CallStack}}\label{fig:CallStackOutput}
\end{figure}
In the tracing output the name of the top level routine does not show up 
since the only call to it is in the driver and the driver routine itself is not being transformed.
% #########################################################################################
\section{Implementation Detrails}\label{sec:implementation}
% +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Analysis}\label{sec:analysis}
 
The tool OpenAD \cite{openad} is the basis for the actual implementation. 
It uses the activity analysis implemented in the OpenAnalysis \cite{oaWeb} library 
to obtain the set of active variables. 
The implementation follows the concepts of data being {\em varied} and {\em usefull}
explained in \refsec{sec:ActivityAnalysis}. 
To permit 

 



      
% -----------------------------------------------------------------------------------------
\subsection{Coverage}

% #########################################################################################
\section*{Acknowledgments}
Utke was supported by the Mathematical, Information, and
Computational Sciences Division subprogram of the Office of Advanced
Scientific Computing Research, Office of Science, U.S. Dept. of Energy under
Contract DE-AC02-06CH11357.  

\bibliographystyle{plain}
\bibliography{tracing}

\vfill
\begin{flushright}
\scriptsize
\framebox{\parbox{2.4in}{The submitted manuscript has been created by
UChicago Argonne, LLC, Operator of Argonne National Laboratory
("Argonne").  Argonne, a U.S. Department of Energy Office
of Science laboratory, is operated under Contract No.
DE-AC02-06CH11357.  The U.S. Government retains for itself, and
others acting on its behalf, a paid-up, nonexclusive, irrevocable
worldwide license in said article to reproduce, prepare derivative works,
distribute copies to the public, and perform publicly and display
publicly, by or on behalf of the Government.}}
\normalsize
\end{flushright}

\end{document}
