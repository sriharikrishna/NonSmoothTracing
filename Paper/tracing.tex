\documentclass{article}

\usepackage[verbose]{wrapfig}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{url}
\usepackage{multirow}
\usepackage{fancyhdr}
\usepackage{relsize}
\usepackage{moreverb}


\usepackage[pdftex,usenames]{color}
\usepackage[pdftex]{graphicx}  
\DeclareGraphicsExtensions{.pdf}  
\usepackage[pdftex,bookmarks=true,bookmarksnumbered=true,hypertexnames=false,breaklinks=true]{hyperref}
\hypersetup{
  pdfauthor = {Jean Utke},
  pdftitle = {Tracing Nonsmooth Model Behavior},
  pdfsubject = {},
  pdfkeywords = {OpenAD, Fortran, automatic differentiation, algorithms},
  pdfcreator = {LaTeX with hyperref package},
  pdfproducer = {dvips + ps2pdf}sh	
}
\pdfadjustspacing=1

% make paragraphs show up in the bookmarks
\setcounter{secnumdepth}{6}
\setcounter{tocdepth}{6}

% names and CS terms
\newcommand{\adolc}{\mbox{Adol-C}}
\newcommand{\openad}{OpenAD}
\newcommand{\adifor}{Adifor}
\newcommand{\xaif}{xaif}

% hyphenation
\hyphenation{OpenAD}

% math
\newcommand{\R}{I\!\!R}
\newcommand{\N}{I\!\!N	}
\newcommand{\bmC}{\mbox{\bf\em C}}
\newcommand{\bmf}{\mbox{\bf\em f}}
\newcommand{\bmfp}{\mbox{\bf\em f$\,^\prime\!\!$}}
\newcommand{\bmg}{\mbox{\bf\em g}}
\newcommand{\bmI}{\mbox{\bf\em I}}
\newcommand{\bmJ}{\mbox{\bf\em J}}
\newcommand{\bmp}{\mbox{\bf\em p}}
\newcommand{\bmq}{\mbox{\bf\em q}}
\newcommand{\bmS}{\mbox{\bf\em S}}
\newcommand{\bms}{\mbox{\bf\em s}}
\newcommand{\bmt}{\mbox{\bf\em t}}
\newcommand{\bmu}{\mbox{\bf\em u}}
\newcommand{\bmv}{\mbox{\bf\em v}}
\newcommand{\bmw}{\mbox{\bf\em w}}
\newcommand{\bmx}{\mbox{\bf\em x}}
\newcommand{\bmy}{\mbox{\bf\em y}}
\newcommand{\bmzero}{\mbox{\bf\em O}}

% environments
\newcommand{\refsec}[1]{{Sec.~\ref{#1}}} 
\newcommand{\refsecBS}[1]{{Section~\ref{#1}}} 
\newcommand{\reffig}[1]{{Fig.~\ref{#1}}} 
\newcommand{\reffigBS}[1]{{Figure\ref{#1}}} 
\newcommand{\reftab}[1]{{Table~\ref{#1}}} 
\newcommand{\refeqn}[1]{{(\ref{#1})}} 
\newcommand{\refdef}[1]{{Def.~(\ref{#1})}} 

\let\verbatiminput=\verbatimtabinput
\def\verbatimtabsize{4\relax}

\title{A Tracing Facility for Nonsmooth Model Behavior}
\author{J. Utke\\\\
\scriptsize draft \input{versionInfo.txt} \\  
\scriptsize compiled on \today\ with \\
\framebox{
\begin{minipage}{6.5cm}
\tiny
\verbatiminput{versionInfoOpenAD.txt}
\end{minipage}
}
}
\date{ } 

\fancyhead[RE]{\leftmark}
\fancyhead[LE]{}
\fancyhead[RO]{}
\fancyhead[LO]{\nouppercase\rightmark}
\fancyfoot[LE,RO]{\date{ }}
\fancyfoot[LO,RE]{Tracing Nonsmooth Model Behavior}

\begin{document}
\maketitle
\lstloadlanguages{Fortran,XML}
\lstset{basicstyle=\small\tt, 
	numbers=left, 
	numberstyle=\scriptsize,
  	stepnumber=1, 
	numbersep=10pt, 
	breaklines=true,
	resetmargins=false,
	xleftmargin=6ex,
	columns=fullflexible}
% #########################################################################################
\section{Introduction}

The computation of derivatives in the context of optimization, parameter, or state estimation 
and other uses relies on the assumption that the function computed by the numerical 
model is in some sense ``smooth''. 
This is true for the approximation of derivative information with divided differences 
as well as the application of automatic differentiation (AD). 
Griewank devotes an entire chapter in \cite{Gri00} 
to the scenario of applying an AD tool to cases without differentiability. 
In practice one observes various cases where the derivatives computed by AD are useless 
because their numerical values grow  beyond reasonable bounds \cite{tfs-delayed,tfs-chain} or even 
become \lstinline{NaN}s.\footnote{
An IEEE floating-point exception indicating ``not a number''.
} 
In the latter case one might have the option of letting a suitable compiler generate 
code to detect floating-point exceptions to help locate the origin of the problem.
The AD  tool ADIFOR \cite{adiforWeb} also has a built-in  option to detect 
such situations by adding checks to the generated code.   
In the former case when no \lstinline{NaN}s are created, however, it is difficult to 
detect what feature of the numerical model causes the derivative values to explode. 
In the following we introduce a facility to trace the model computation and locate 
certain programming constructs that have the potential to cause 
such behavior. We aim at extracting information specific both  to 
certain locations in the underlying program and to certain data 
being computed during the execution of the model.  
   
Many numerical models exhibit nonsmooth behavior to reflect the modeled problem, 
for instance a phase change in the modeled material, because the 
model has distinct representations for certain subdomains or the nonsmooth effects 
are an artifact of the numerical methods implemented in the model.
In either case one needs to be concerned about the validity of the 
derivative information and attempt to locate the problem and  find a remedy.  
The situation with distinct subdomains is described in \cite{adolc} to illustrate 
certain aspects of using \adolc, and  we 
replicate it here in \reffig{fig:subdomains}. 
\begin{figure}
\centerline{\includegraphics[width=6cm]{nonsmooth1}}
\caption{A nonsmooth model with subdomains}\label{fig:subdomains} 
\end{figure}
The model is first evaluated at point P0.  Relative to P0 we distinguish the 
following cases.
\begin{description}
\item[P1] We stay in the interior of the same subdomain as P0.
\item[P2 and P2'] We are in the interior of a different subdomain from P0.
\item[P3] We are at a point where the model is continuous but not (Frech\'et) differentiable.
\item[P4] We are at a point where the model is not continuous.
\item[P5] We are at a point where the model is not defined.
\end{description}    
For \adolc\  the most critical question is to determine whether a given execution trace 
recorded for some point P0 may still be used for a different point P' or else 
into which of the five categories  the point P' falls that would necessitate 
a re-recording of the execution trace and indicate whether the computed derivatives 
may be valid only in the given direction. \adolc\  itself provides an answer only 
via a return code indicating the category. 
It does so by comparing the output of tests and certain intrinsics 
recorded in the execution trace with the output these same tests and intrinsics 
generate at the current evaluation point. 
Because the execution trace is generated via operator overloading and is designed to 
minimize the required storage, an indication of leaving the current subdomain or computing 
a value at a point of nondifferentiability cannot be related to a particular spot in 
the underlying program or a particular piece of data. 
However, the idea is the same: tracking the behavior of certain programming constructs we 
obtain an indication  if we left the subdomain in which smooth model behavior 
can be assumed. 
These {\em critical} programming constructs can be grouped as follows.
\begin{description}
\item[nonsmooth intrinsics] Some of the most obvious cases are \lstinline{max}, \lstinline{min}, and \lstinline{fabs}.
\item[conditional expressions] The model may compute values in different branches following a test, 
or a loop may have a different iteration count based on a termination test.
\end{description}
As done in \adolc, we aim at tracing the model behavior and detecting any differences triggered 
by the programming constructs listed above that might represent nonsmooth model behavior.
Obviously a tracing facility such as the one proposed here is most useful for 
numerical models that have 
\begin{itemize}
\item a large source code base and 
\item a relatively long execution time
\end{itemize}
such that a manual inspection of the model -- either by browsing the source code or 
by running a simulation in the debugger to observe certain values -- is too tedious.
Clearly such a use also requires some restrictions on the information being 
collected, in order to reduce the amount of tracing data that has to be dealt with.


% #########################################################################################
\section{Usage}

The source transformation that provides the tracing facility is implemented in the 
\openad\ framework \cite{openad}. The website\\[1ex] 
\centerline{\url{www.mcs.anl.gov/openad}}\\[1ex]
provides details on downloading and building the tool chain. 

% -----------------------------------------------------------------------------------------
\subsection{A Simple Example}
We assume a simple routine, see \reffig{fig:OneMinute} (left), computing $y=f(x)=\tan(x)$ implemented by \lstinline{head}.
\begin{figure}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[frame=single]{Code/OneMinuteExample/head.f90}
\end{minipage}
\begin{minipage}[t]{.48\linewidth}
\lstinputlisting[frame=single]{Code/OneMinuteExample/head.prepped.f90}
\end{minipage}
\caption{Simple example code (left), prepared for tracing (right)}\label{fig:OneMinute}
\end{figure}
We need to prepare the code for the activity analysis by specifying the independent variables
(here \lstinline{x}) and the dependent variables 
(here \lstinline{y}) shown in lines 4 and 6 of \reffig{fig:OneMinute} (right).
In the following we assume the \openad\ environment has been set up as 
described in \cite{userManual}, Sect. 2.2.
For this simple example we can use the following wrapper script.\\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/bin/openad}\\[1ex] %$
The environment setup adds this directory to the \lstinline{PATH}.
All script options are shown when it is invoked with the \lstinline{-h} flag. 
It provides a simple recipe for the tracing transformation that we can use in 
a straightforward case like this by calling %\\[1ex]
\begin{wrapfigure}[25]{r}{.5\textwidth}
\begin{minipage}{.98\linewidth}
\lstinputlisting[frame=single]{Code/OneMinuteExample/driver.f90}
\end{minipage}
\caption{Driver routine for the transformed code  shown in \reffig{fig:OneMinuteTransformed} }\label{fig:OneMinuteDriver}
\end{wrapfigure}
\hspace*{.3cm}\lstinline{openad -c -m t head.prepped.f90}\\[1ex]
%it produces some progress output like the one shown in \reffig{fig:oneMinuteStatusOutput}.
The resulting Fortran output is contained in a file called\\[1ex]
\hspace*{.3cm}\lstinline{head.prepped.xb.x2w.w2f.pp.f}\\[1ex] 
and its contents is shown in \reffig{fig:OneMinuteTransformed}.  
In the transformed Fortran one finds two versions of the code: one is the original 
on line 28, and one is augmented on
lines 32--36. Which version is being run depends 
%\begin{wrapfigure}{r}{.5\textwidth}
%\begin{minipage}{.95\linewidth}
%\scriptsize\verbatiminput{oneMinuteStatusOutput.txt}
%\end{minipage}
%\caption{Status messages from \lstinline{openad}.}\label{fig:oneMinuteStatusOutput}
%\end{wrapfigure}
on the value of the components of \lstinline{our_rev_mode}, which is to be controlled 
by a driver that calls \lstinline{head(x,y)}.
A simple driver is shown in \reffig{fig:OneMinuteDriver}. 
On line 11 a generic initialization 
of the tracing environment is performed.  A first trace is 
started on line 12. The call to 
\lstinline{oad_trace_open} 
opens a file called 
\lstinline{oad_tr_001.xml} 
and sets up the running mode \lstinline{oad_rev_mode} 
referenced on lines 26 and 30 of \reffig{fig:OneMinuteTransformed}.
In the driver we then change the value at which we compute \lstinline{head} and 
open a second trace, named \lstinline{oad_tr_002.xml}. 
The \lstinline{openad} script links the required runtime support files 
to the working directory, and all files can be compiled with 
a \lstinline{makefile} such as the one shown in \reffig{fig:OneMinuteMake}.
The contents of the trace output files generated when running \lstinline{driver} 
is shown in \reffig{fig:OneMinuteXMLOutput}.
\begin{figure}[h]
\fbox{
\begin{minipage}{.95\textwidth}
\scriptsize
\verbatiminput{Code/OneMinuteExample/Makefile}
%\verbatimfile{Code/OneMinuteExample/Makefile}
\end{minipage}
}
\caption{Contents of a \lstinline{makefile} to compile and link the example}\label{fig:OneMinuteMake}.
\end{figure}
\begin{figure}
\lstinputlisting[frame=single]{Code/OneMinuteExample/head.prepped.xb.x2w.w2f.pp.f}
\caption{Transformed code (fixed format) from input shown in \reffig{fig:OneMinute} (left)}\label{fig:OneMinuteTransformed}
\end{figure}
\begin{figure}
\begin{minipage}{.49\textwidth}
\lstinputlisting[frame=single,numbers=left,xleftmargin=4ex,language=XML]{Code/OneMinuteExample/oad_tr_001.xml}
\end{minipage}
\hspace*{1ex}
\begin{minipage}{.46\textwidth}
\lstinputlisting[frame=single,numbers=none,xleftmargin=0ex,language=XML]{Code/OneMinuteExample/oad_tr_002.xml}
\end{minipage}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated from running the driver in \reffig{fig:OneMinuteDriver}}\label{fig:OneMinuteXMLOutput}
\end{figure}
Clearly the tracing outputs are identical except for line 4, where we show the 
different output for the respective smooth subdomain \lstinline{sd} at which the 
\lstinline{tan} intrinsic is being evaluated. The interpretation of the subdomain of $\tan(x)$ 
is \lstinline{sd=}$k$ with integer $k=\lfloor\frac{x+\pi/2}{\pi}\rfloor$, and in our 
example the change in the \lstinline{sd} value  indicates that we moved from one smooth 
subdomain to another. 
We note that the subdomain is computed when the intrinsic is called. Lines 2 and 3 
are generated separately before the call, in order to allow the generation of line number information 
and, if necessary,  information about the arguments; see also \refsec{sec:ArrayIndex}.

% -----------------------------------------------------------------------------------------
\subsection{Detailled Usage}
The source code is transformed in stages in the same fashion as 
summarized in the \openad\ Manual \cite{userManual}, Sect. 2.5. 
The differences in the tool chain are the choice of the transformation algorithm 
in the \lstinline{xaifBooster} component and the selection of the runtime library in connection with 
the postprocessor templates. 
The stages prior to the tracing transformation are as follows.
\begin{itemize}
\item Collecting all the model program sources into a  single source code file; declaration of independent and dependent program variables (see \cite{userManual}, Sect. 2.3)
\item Canonicalizing (optional, see \cite{userManual}, Sect. 4.2.1)
\item Parsing Fortran with the Open64 front-end (\lstinline{mfef90}, see \cite{userManual}, Sect. 4.2.2)
\item Translating the Open64 internal representation to xaif (\lstinline{whirl2xaif}, see \cite{userManual}, Sect. 4.2.3)
\end{itemize}
The steps following the core tracing transformation are as follows.
\begin{itemize}
\item Translating from xaif to the Open64 internal representation (\lstinline{xaif2whirl}, see \cite{userManual}, Sect. 4.2.3)
\item Unparsing the Open64 internal representation into Fortran (\lstinline{whirl2f}, see \cite{userManual}, Sect. 4.2.2)
\item Postprocessing (see \cite{userManual}, Sect. 4.2.4)
\item Compiling and linking (see \cite{userManual}, Sect. 2.6)
\end{itemize}
% -----------------------------------------------------------------------------------------
\subsubsection{The Tracing Transformation}
The numerical model is now given as an xaif file to which we apply the tracing transformation. 
Conceptually, the tracing transformation shares the following aspects with other 
AD-related transformations implemented in 
\openad.
\begin{itemize}
\item Redeclaration of program variables using a special, {\em active} type these variables 
	have been determined by the activity analysis to hold active values
\item Transformation associated with this type change, for instance as  applied to 
	calls to black-box subroutines
\item Augmentation of the control flow graph, for instance to be able to count loop iterations
\end{itemize}
The source code for the transformation can be found in \lstinline{inc} and \lstinline{src} under \\[1ex]   
\hspace*{.3cm}\lstinline{$OPENADROOT/xaifBooster/algorithms/TraceDiff} \\[1ex]%$
with the top level  driver routine being in \lstinline{driver/oadDriver.cpp}. 
The transformation options associated with the tracing facility are as follows.
{\scriptsize \verbatiminput{tracingAlgOpts.txt}}
As shown in \reffig{fig:OneMinuteTransformed}, the 
transformation generates two versions of the input code on a per subroutine basis. 
The first one is essentially the input containing only changes related to the 
type change of active variables. The second version is the actual tracing. 
% -----------------------------------------------------------------------------------------
\subsubsection{Runtime Support Files}
The following files support the implementation of the tracing transformation.
\begin{description}
\item[{\tt ad\_template.f}:] the template file used by the postprocessor to inject the two code versions created per 
subroutine into a control structure that makes up the new subroutine body; a simple version of such a template file 
can be found in\\[1ex]   
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/simple/ad_template.trace.f} \\[1ex]%$
The name of the template file can be specified to the postprocessor script \lstinline{multi-pp.pl} by using
\lstinline{-f <template_file_name>} or specified in the source code inside each subroutine body by using 
a pragma of the following format. \\[1ex]
\hspace*{.3cm}\lstinline{!$openad  XXX Template <template_file_name>} \\[1ex]%$ 
If nothing is specified, the postprocessor expects a template file named \lstinline{ad_template.f} in the 
current working directory.  \\[1ex]
\item[{\tt OAD\_trace.f90:}] located in \lstinline{$OPENADROOT/runTimeSupport/simple/} % $
is the module that contains 
the routines used to generate the trace xml output. For instance, related to the tracing of 
the calls to the \lstinline{tan} intrinsic, the module contains procedures such as the following.
\lstinputlisting[firstline=300,lastline=304,numbers=none,xleftmargin=0ex,basicstyle=\scriptsize\tt]{Code/OneMinuteExample/OAD_trace.f90}
The routines to be called directly by the user are discussed in \refsec{sec:DriverRoutine}.
\item[{\tt w2f\_\_types.f90} and {\tt iaddr.c}:] the generic support files needed by most 
\openad\ transformed source code;
the files can be found in \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/all/}%$
\item[{\tt OAD\_active.f90} and {\tt OAD\_rev.f90}:] the definition for the active type and the state 
controlling the version of the code to be executed;
the files can be found in \\[1ex]
\hspace*{.3cm}\lstinline{$OPENADROOT/runTimeSupport/simple/}%$
\end{description}
Except for the template file listed as the first item, all other files are just compiled and linked 
with the transformed model source and a suitable driver.

% -----------------------------------------------------------------------------------------
\subsubsection{Driver Routine}\label{sec:DriverRoutine}

We assume some program logic (the {\em driver}) 
that initializes the input variables of the model, executes the model 
computation itself, and then processes the output values. 
That driver logic  is the natural location for orchestrating the tracing of the model. 
All the required elements to be added to the driver logic are already given in the example 
in \reffig{fig:OneMinuteDriver}. The required modules to be \lstinline{USE}d 
are \lstinline{OAD_active} and 
\lstinline{OAD_trace}. A third module \lstinline{OAD_rev} is used by \lstinline{OAD_trace}
internally. The routines to be called by user in the driver are as follows.
\begin{description}
\item[{\tt oad\_trace\_init}:] initialize the tracing module by resetting the file counter
\item[{\tt oad\_trace\_open}:] start a new trace; increment the file name counter 
\item[{\tt oad\_trace\_close}:] close a trace file opened with \lstinline{oad_trace_open}
\end{description}   
If the scope of the trace is smaller than the 
entire model computation (see also \refsec{sec:GrowingDerivatives}),
it may be necessary to place pairs of calls to \lstinline{oad_trace_open} 
and \lstinline{oad_trace_close} inside the model 
source code. 

% +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Concepts}
This section provides some details on the underlying concepts to 
better understand the goal of the tracing facility and what it can and cannot accomplish. 
% -----------------------------------------------------------------------------------------
\subsection{Tracing and Activity Analysis}\label{sec:ActivityAnalysis}
An important concept in AD is that of {\em active} values, that is, 
program data that lies on a dependency path from the subset of inputs $\bmx$ to 
a subset of outputs $\bmy$. 
In a source transformation context the activity is determined by a data flow 
analysis. Typically the dependence of a given value on $\bmx$ is 
referred to as being {\em varied}, while $\bmy$ depending on 
a certain value is referred to as that value being {\em useful}.   
In general we assume a model of the form 
\[
(\bmy,\bmq)=\bmf(\bmx,\bmp): \R^{n\times s}\mapsto \R^{m\times t}\quad.
\]
The inputs $\bmp$ and the outputs $\bmq$  are assumed to be of no interest 
for the derivative computation. Consequently any values that depend only on
$\bmp$ or affect only $\bmq$ are not active values and  
under certain conditions of no interest to the trace we need to compare against. 
We note that this restriction is specific to the AD context 
and is the distinguishing factor that separates our  approach  
from something that might otherwise be accomplished 
by using, for example, aspect-oriented programming techniques.\footnote{
To our knowledge an AOP system for Fortran does not exist.
}  
Typical examples for portions of the code that do not involve active values 
is logic for debugging, logging, timing, or I/O.   

Our approach relies on compile time activity analysis to determine the active value set 
and source transformation to augment the critical programming constructs by 
routines that generate the trace. 
Because of conservative assumptions regarding the 
aliasing of variables, there is a certain overestimate of the active value set. 
The overestimate could in theory be reduced by augmenting the static analysis 
with runtime data. 
Such runtime augmentation has,  however,  the same principal problem as does the use
of the \adolc\  trace. 
One will always have to check 
whether the runtime data is still  
\begin{wrapfigure}[13]{r}{.5\textwidth}
\begin{minipage}{.95\linewidth}
\begin{lstlisting}[frame=single]
v = t + sin(a) 
if ( v .gt. 0.3 )
then 
  a = a * 2
else
  a = a * 3
end if 
...
\end{lstlisting}
\end{minipage}
\caption{A control flow decision depending on a nonactive variable}\label{fig:missedThis} 
\end{wrapfigure}
valid once the point of evaluation moves. 
In other words it would be subject to the same nonsmooth model behavior we are trying to detect.
On the other hand, clearly the activity  analysis requiring a value 
to be both varied and useful can underestimate 
the values for which tracing may be desired.
The example in \reffig{fig:missedThis} illustrates the case of an active value  $a$
being part of the computation of some value $p$ that itself is not active presumably 
because it is ``varied'' but not ``useful''.
Then $v$ is used in an if-condition that changes the path through the control flow 
graph for some  subsequent computation of active values.
Given this scenario, one might arrive at various conclusions. 

Rather than tracing critical constructs only for  active values, 
one could devise an extension to the notion of activity using the following 
definition.\\
{\bf\em  Definition: } A value is called {\em indirectly useful} 
if it is used in an address computation that impacts 
the  computation of active values.\\
Here we use the term  ``address computation'' not only  to cover the typical notion of 
computing addresses in the program's data segment but also to compute 
addresses in the programs text segment determining the next instruction. 
The instruction address computation is already illustrated by \reffig{fig:missedThis}.
An example for the former kind of address computation is given in 
\reffig{fig:addressComp}, where an active value in variable a is used to 
determine an index \lstinline{i} into a lookup table t,
\begin{wrapfigure}{r}{.5\textwidth}
\begin{minipage}{.95\linewidth}
\begin{lstlisting}[frame=single]
i = int(a) 
a = a * t(i)
\end{lstlisting}
\end{minipage}
\caption{An address computation into a lookup table impacting the subsequent computation}\label{fig:addressComp} 
\end{wrapfigure}
which then is used in 
subsequent active computations.
Unfortunately the definition of ``indirectly useful'' cannot be readily translated  into a data flow analysis and requires research that goes beyond the scope of this paper.   

An alternative is  to  trace critical constructs for all varied values. 
Clearly, this will increase the generated output significantly by including much 
of the ancillary model logic (the aforementioned debugging, monitoring, etc.) that 
the activity analysis is aiming to exclude. 
Incidentally, in \adolc\ this approach is implicitly enforced by the compiler. 
\adolc\ uses a specific  
active type for active values, and they may not be used to 
compute plain floating-point values unless one 
explicitly deactivates the value first. 

Given the difficulty of implementing an analysis to determine indirectly useful values 
and the large overhead of tracing all varied values, we 
compromise with a limited extension to the notion of active variables by tracing  
all expressions in control flow constructs and address computations directly involving active values
but excluding all cases of computing nonactive values that use one or more intermediate 
variables before the actual address computation takes place. 
While this opens up the possibility of missing some critical constructs, 
it also permits a tighter restriction on what is being traced as a first iteration. 
Other than the size of the tracing data  there is no problem with abandoning the compromise
and using just the set of varied values, should the first iteration not be able to 
locate any problems.    
In \refsec{sec:analysis} we discuss the practical implementation.

% -----------------------------------------------------------------------------------------
\subsection{Growing Derivatives}\label{sec:GrowingDerivatives}
In various practical applications of AD it was observed that particularly in iterative
models there are cases where the  computed derivatives before a certain iteration count 
oscillate and grow out of bounds. 
This situation was described, for instance, in \cite{tfs-delayed}. 
We do not presume any knowledge about the origin of the nonsmooth behavior; for instance,
it may well originate with an erroneous implementation of a numerical method. 
A simple example will illustrate how oscillating derivatives and the growth 
of the amplitude might be related to switching between smooth subdomains. 
Consider an iteration internal to the model that computes some physical state 
on a discretized domain but, because of a condition, the state value is 
forced to attain another value. For example, one might think of a heating process involving 
a phase change in which the temperature \lstinline{T(0)} of a 
material is forced down to a certain ambient 
value \lstinline{bT} on the boundary of the model domain, while 
the interior temperature \lstinline{T(i)} with \lstinline{i}$>0$ is not directly forced.  
Over the time steps  one first observes a smooth rise in \lstinline{T} 
until the 
regime that governs the phase change triggers a nonsmooth behavior. 
The situation is illustrated in \reffig{fig:growingExample}.
\begin{figure}
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[frame=single,numbers=none,xleftmargin=0ex]
do while time<timeE
  call computeTemp(T)
  if (T(0)>bT+delta) then 
    T(0) = bT 
  end if
  time = time + step
end do  
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{.4\textwidth}
\includegraphics[width=.8\linewidth]{nonsmooth2}
\end{minipage}
\caption{An iterative model with nonsmooth behavior yields 
growing derivative values.}\label{fig:growingExample} 
\end{figure}
An oscillation of the derivative values can originate, for example, from 
switching between two subdomains as depicted in  \reffig{fig:oscillatingExample}.
\begin{figure}
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[frame=single,numbers=none,xleftmargin=0ex]
do while time<timeE
  if (a>aCrit) 
  then
     a=a+updF1(a)
  else 	
     a=a+updF2(a)
  end if
  time=time+step
end do  
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{.4\textwidth}
\includegraphics[width=\linewidth]{nonsmooth3}
\end{minipage}
\caption{An iterative model with nonsmooth behavior yields 
oscillating derivative values.}\label{fig:oscillatingExample} 
\end{figure}
The solution to fixing the model behavior in this simple example is obvious,
but in complicated numerical models the effect of the updated in combination with 
switching the model regime in the control flow may not be obvious at all. 
Using the suggested tracing, one would, however, record the switches in 
the control flow path based on the value of a. 
Both examples also indicate that one has to consider the  scope in which 
one wants to compare traces. Here we assume a time-stepping scheme 
outside the ``core'' model we are tracing, and this implies a comparison 
of traces for different time steps.  
If a model already contains iterations (e.g., if we consider the time-stepping 
loops part of our example models) one will have to narrow the scope to 
subtraces within the model. 

% #########################################################################################
\section{Examples}
A study of a large computation with  the MIT general circulation model 
is under way.  
Here we illustrate the use of the tracing facility on three small examples.
% -----------------------------------------------------------------------------------------
\subsection{Control Flow}
\begin{figure}
\begin{minipage}{.48\linewidth}
\lstinputlisting[frame=single]{Code/ControlFlow/head.prepped.f90}
\end{minipage}
\begin{minipage}{.48\linewidth}
\lstinputlisting[frame=single]{Code/ArrayIndex/head.prepped.f90}
\end{minipage}
\caption{Example for control flow decisions depending on active variables (left); example for tracing array indices in select intrinsics (right)}\label{fig:ControlFlowArrayIndex} 
\end{figure} 
Control flow decisions depending on active variables are illustrated in the example in 
\reffig{fig:ControlFlowArrayIndex}(left).
Both the loop bounds and the branch condition 
depend on the active input.  
The XML tracing elements representing structured control flow constructs are nested accordingly. 
The \lstinline{<Cfval>} element preceding a \lstinline{</Branch>} indicates what the branch 
condition evaluated to. Similarly, the \lstinline{<Cfval>} element preceding a \lstinline{</Loop>} 
indicates the number of loop iterations performed.       
The \lstinline{head} routine 
is run at two  points [0.5,0.75] and [0.5,1.75] for 
the inputs [\lstinline{x1},\lstinline{x1}].
For the first point 
the loop has three iterations, for the second point four. The condition in the 
loop body always evaluates to false for the first point and to true in the last three loop iterations for the second point. The output files are shown in \reffig{fig:ControlFlowOutput}. 
\begin{figure}
\begin{minipage}[t]{.48\textwidth}
\lstinputlisting[frame=single]{Code/ControlFlow/oad_tr_001.xml}
\end{minipage}
\begin{minipage}[t]{.48\textwidth}
\lstinputlisting[frame=single]{Code/ControlFlow/oad_tr_002.xml}
\end{minipage}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated for \reffig{fig:ControlFlowArrayIndex}(left)}\label{fig:ControlFlowOutput}
\end{figure}
The structure may become more apparent if the xml file is viewed  
with a browser such as Firefox that has an appropriate style sheet for presenting xml files 
and allows an element and the contents nested inside to collapse and expand. 
% -----------------------------------------------------------------------------------------
\subsection{Array Indices}\label{sec:ArrayIndex}
\begin{figure}
\begin{minipage}{.5\textwidth}
\lstinputlisting[frame=single]{Code/ArrayIndex/oad_tr_001.xml}
\end{minipage}
\begin{minipage}{.46\textwidth}
\lstinputlisting[frame=single,numbers=none,xleftmargin=2ex]{Code/ArrayIndex/oad_tr_002.xml}
\end{minipage}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated for \reffig{fig:ControlFlowArrayIndex}(right)}\label{fig:ArrayIndexOutput}
\end{figure}
It may not always be straightforward to determine which program variables 
are being referenced, in particular if one uses array indices but the loop 
boundaries do not depend on active variables. Consequently the trace will 
also contain index values to help determine which data causes a change. 
Such a case is shown in \reffig{fig:ControlFlowArrayIndex}(right).
We compute the \lstinline{head} routine at points [0.5,0.75] and [0.5,3.75].
For the first point both calls to $\tan$ are in subdomain 0; for the second 
point the second call is in subdomain 1. Looking at the output shown in \reffig{fig:ArrayIndexOutput},
we see that for each call to $\tan$ we also show the index of the active argument. 
This allows us to easily pinpoint changes for certain elements in large arrays.    
% -----------------------------------------------------------------------------------------
\subsection{Call Stack}
\begin{figure}
\centerline{\begin{minipage}{.48\linewidth}
\lstinputlisting[frame=single]{Code/CallStack/head.prepped.f90}
\end{minipage}
}
\caption{Example for tracing subroutine calls}\label{fig:CallStack} 
\end{figure} 
In the output shown so far, the listing of the line numbers and the 
nesting of the 
respective XML elements provide some means of navigating the 
tracing output. A natural higher level of XML element nesting would be 
the subroutine. For that reason we also introduce subroutine calls into the trace. 
The example in \reffig{fig:CallStack} shows routines \lstinline{foo} and \lstinline{bar}
called within \lstinline{head}.
We compute the \lstinline{head} routine at points 0.5 and 1.0. Because \lstinline{bar} 
is called both within \lstinline{foo} and directly in \lstinline{head}, it would be 
helpful to know the callstack at the point of a tracing difference. 
For better readability the output shown in \reffig{fig:ArrayIndexOutput} has  
been reformatted with \lstinline{xmlformat} \cite{xmlformat} and 
indicates that the only change in the subdomain (third line from the bottom)
is related to the call to \lstinline{bar} made directly in foo.
\begin{figure}
\fbox{
\begin{minipage}{.45\textwidth}
\scriptsize
\verbatiminput{Code/CallStack/oad_tr_001.fxml}
\end{minipage}
}
\fbox{
\begin{minipage}{.45\textwidth}
\scriptsize
\verbatiminput{Code/CallStack/oad_tr_002.fxml}
\end{minipage}
}
\caption{Output \lstinline{oad_tr_001.xml} (left) 
and \lstinline{oad_tr_002.xml} (right) 
generated for \reffig{fig:CallStack}}\label{fig:CallStackOutput}
\end{figure}
In the tracing output the name of the top-level routine does not show up 
since the only call to it is in the driver and the driver routine itself is not being transformed.
% #########################################################################################
\section{Implementation and Installation}\label{sec:implementation}
In the following we provide some information on the implementation where it differs 
from the OpenAD manual \cite{userManual}.  
% +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Analysis}\label{sec:analysis}
 
The \openad\ \cite{openad} tool chain is the basis for the actual implementation. 
It uses the activity analysis implemented in the OpenAnalysis \cite{oaWeb} library 
to obtain the set of active variables. 
The implementation follows the concepts of data being {\em varied} and {\em useful}
explained in \refsec{sec:ActivityAnalysis}. 
To permit a larger scope of variables being traced, we can designate variables only 
by their {\em varied} status by calling the \lstinline{whirl2xaif} transformation stage 
with the \lstinline{-v} flag. This flag triggers a modified data flow analysis. 
Because this is not one of the common recipes, the option is not provided by 
the \lstinline{openad} script. Instead, one would typically use a makefile 
for the individual transformation steps as explained in  \cite{userManual}, Sect. 2.5.
      
% -----------------------------------------------------------------------------------------
\subsection{Coverage}
While the prinicpal mechanism discussed here is language independent,
the tracing trasnformation in the  
the language dependent parts of the OpenAD toolchain have been implemented only for Fortran. 
\begin{description}
\item[Control FLow Constructs:] For structured control flow,  loops and branches are being traced; 
for each construct the iteration count or the condition value is being reported. 
For general, unstructured control flow no such output is being created. In practice 
it would require tracing the entrance and exit of basic blocks by some identifier such as the line number,
and this feature is currently not implemented.
\item[intrinsics:] The following intrinsics trigger tracing output.
\begin{description}
\item[abs] if the argument value is positive \lstinline{v=}$+$ else \lstinline{v=}$-$
\item[division] if the denominator is positive \lstinline{d=}$+$ else \lstinline{d=}$-$   
\item[ceiling, floor, int, nint, modulo] the resulting value
\item[max] the maximal argument
\item[min] the minimal argument
\item[sign] if the sign of the first argument changed \lstinline{d=}$+$ else \lstinline{d=}$-$
\item[tan] identifying the subdomain as \lstinline{sd=}$\lfloor\frac{x+\pi/2)}{\pi}\rfloor$ 
\end{description}
\end{description}

% -----------------------------------------------------------------------------------------
\subsection{Installation}
Because the algorithm is integrated into \openad, 
one can follow the installation and build instructions given on the \openad\ website \cite{openadWeb}.
The website also contains instructions about how to contribute to the \openad\ source.
To rebuild this document from the \LaTeX\ sources requires the \openad\ environment to be 
set (see \cite{userManual} Sect. 2.2)  because 
the examples are being transformed and run as part of the build process. 
 
% #########################################################################################
\section*{Acknowledgments}
Utke was supported by the Mathematical, Information, and
Computational Sciences Division subprogram of the Office of Advanced
Scientific Computing Research, Office of Science, U.S. Dept. of Energy under
Contract DE-AC02-06CH11357.  

\bibliographystyle{plain}
\bibliography{tracing}

\vfill
\begin{flushright}
\scriptsize
\framebox{\parbox{2.4in}{The submitted manuscript has been created by
UChicago Argonne, LLC, Operator of Argonne National Laboratory
(``Argonne'').  Argonne, a U.S. Department of Energy Office
of Science laboratory, is operated under Contract No.
DE-AC02-06CH11357.  The U.S. Government retains for itself, and
others acting on its behalf, a paid-up, nonexclusive, irrevocable
worldwide license in said article to reproduce, prepare derivative works,
distribute copies to the public, and perform publicly and display
publicly, by or on behalf of the Government.}}
\normalsize
\end{flushright}

\end{document}
